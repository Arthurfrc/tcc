Abrir o prompt e rodar o comando abaixo:
"python -m http.server"
Rodar também
"python api.py"

Depois de estar rodando o servidor, abrir o browser em:
http://localhost:8000/projeto-busca-carros


import requests
import urllib.parse
from typing import Dict, List, Tuple, Optional
import time
import random

class WebmotorsAPI:
    def __init__(self):
        self.base_url = "https://www.webmotors.com.br/api/search/car"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'pt-BR,pt;q=0.9,en;q=0.8',
            'Referer': 'https://www.webmotors.com.br/',
            'Origin': 'https://www.webmotors.com.br'
        }
    
    def _normalizar_string(self, texto: str) -> str:
        """Normaliza strings removendo acentos e caracteres especiais"""
        import unicodedata
        texto = unicodedata.normalize('NFD', texto)
        texto = ''.join(c for c in texto if not unicodedata.combining(c))
        return texto.strip()
    
    def _construir_url_busca(self, marca: str, modelo: str, pagina: int = 1, 
                           limite_por_pagina: int = 47) -> str:
        """Constrói a URL de busca dinamicamente baseado nos padrões reais da Webmotors"""
        
        # Normalizar e formatar parâmetros
        marca_lower = self._normalizar_string(marca.lower())
        modelo_lower = self._normalizar_string(modelo.lower())
        marca_upper = self._normalizar_string(marca.upper())
        modelo_upper = self._normalizar_string(modelo.upper())
        modelo_title = self._normalizar_string(modelo.title())
        
        # URL base da busca interna
        search_url = f"https://www.webmotors.com.br/carros/estoque/{marca_lower}/{modelo_lower}"
        
        # Parâmetros da URL interna - padrão mais genérico baseado nos exemplos
        search_params = {
            'autocomplete': marca_title,  # Pode ser marca ou modelo dependendo do caso
            'autocompleteTerm': f"{marca_title} {modelo_title}",
            'lkid': '1705',  # Parâmetro presente nos exemplos
            'tipoveiculo': 'carros',
            'marca1': marca_upper,
            'modelo1': modelo_upper,
            'page': str(pagina)
        }
        
        # Para alguns casos específicos, ajustar o autocomplete
        # BYD Seal usa "byd" no autocomplete
        # Ford Ka usa "Ford" no autocomplete
        if marca_lower == 'byd':
            search_params['autocomplete'] = marca_lower
        elif marca_lower in ['ford', 'chevrolet', 'volkswagen', 'toyota', 'honda']:
            search_params['autocomplete'] = marca_title
        else:
            # Para marcas como BMW, Mercedes, Audi, etc.
            search_params['autocomplete'] = modelo_lower
        
        # Montar URL com parâmetros
        search_url_with_params = search_url + '?' + urllib.parse.urlencode(search_params)
        
        # Parâmetros da API
        api_params = {
            'displayPerPage': str(limite_por_pagina),
            'actualPage': str(pagina),
            'showMenu': 'true',
            'showCount': 'true',
            'showBreadCrumb': 'true',
            'order': '1',  # 1 = Relevância, 2 = Menor preço, 3 = Maior preço, 4 = Mais novo, 5 = Mais antigo
            'url': search_url_with_params,
            'mediaZeroKm': 'true'
        }
        
        return self.base_url + '?' + urllib.parse.urlencode(api_params)
    
    def buscar_precos(self, marca: str, modelo: str, limite: int = 10, 
                     ordem: int = 1, paginas: int = 1) -> Dict:
        """
        Busca preços de veículos na Webmotors
        
        Args:
            marca: Marca do veículo (ex: 'BMW')
            modelo: Modelo do veículo (ex: 'X5')
            limite: Número máximo de anúncios para retornar
            ordem: Ordem dos resultados (1=Relevância, 2=Menor preço, 3=Maior preço)
            paginas: Número de páginas para buscar
            
        Returns:
            Dict com estatísticas e lista de anúncios
        """
        
        todos_anuncios = []
        todos_precos = []
        
        try:
            for pagina in range(1, paginas + 1):
                url = self._construir_url_busca(marca, modelo, pagina)
                
                # Delay entre requests para evitar rate limiting
                if pagina > 1:
                    time.sleep(random.uniform(0.5, 1.5))
                
                response = requests.get(url, headers=self.headers, timeout=10)
                
                if response.status_code != 200:
                    print(f"Erro na página {pagina}: Status {response.status_code}")
                    continue
                
                data = response.json()
                anuncios = data.get("SearchResults", [])
                
                if not anuncios:
                    print(f"Nenhum resultado encontrado na página {pagina}")
                    break
                
                # Processar anúncios da página atual
                for anuncio in anuncios:
                    if len(todos_anuncios) >= limite:
                        break
                    
                    price_info = anuncio.get("Prices", {})
                    price = price_info.get("Price")
                    
                    if price and price > 0:
                        anuncio_info = {
                            'preco': float(price),
                            'titulo': anuncio.get("Title", ""),
                            'ano': anuncio.get("Year", ""),
                            'quilometragem': anuncio.get("Mileage", ""),
                            'cidade': anuncio.get("City", ""),
                            'estado': anuncio.get("State", ""),
                            'url': f"https://www.webmotors.com.br{anuncio.get('DetailURL', '')}",
                            'imagem': anuncio.get("Image", "")
                        }
                        
                        todos_anuncios.append(anuncio_info)
                        todos_precos.append(float(price))
                
                if len(todos_anuncios) >= limite:
                    break
            
            # Calcular estatísticas
            if todos_precos:
                estatisticas = {
                    'quantidade': len(todos_precos),
                    'preco_medio': sum(todos_precos) / len(todos_precos),
                    'preco_minimo': min(todos_precos),
                    'preco_maximo': max(todos_precos),
                    'preco_mediano': sorted(todos_precos)[len(todos_precos)//2]
                }
            else:
                estatisticas = {
                    'quantidade': 0,
                    'preco_medio': 0,
                    'preco_minimo': 0,
                    'preco_maximo': 0,
                    'preco_mediano': 0
                }
            
            return {
                'sucesso': True,
                'marca': marca,
                'modelo': modelo,
                'estatisticas': estatisticas,
                'anuncios': todos_anuncios,
                'mensagem': f"Encontrados {len(todos_anuncios)} anúncios para {marca} {modelo}"
            }
            
        except requests.exceptions.RequestException as e:
            return {
                'sucesso': False,
                'erro': f"Erro de conexão: {str(e)}",
                'anuncios': [],
                'estatisticas': {}
            }
        except Exception as e:
            return {
                'sucesso': False,
                'erro': f"Erro inesperado: {str(e)}",
                'anuncios': [],
                'estatisticas': {}
            }

# Função auxiliar para uso mais simples
def buscar_precos_webmotors(marca: str, modelo: str, limite: int = 10) -> Tuple[float, List[float]]:
    """
    Função simplificada que retorna apenas preço médio e lista de preços
    Mantém compatibilidade com sua função original
    """
    api = WebmotorsAPI()
    resultado = api.buscar_precos(marca, modelo, limite)
    
    if resultado['sucesso'] and resultado['estatisticas']['quantidade'] > 0:
        precos = [anuncio['preco'] for anuncio in resultado['anuncios']]
        return resultado['estatisticas']['preco_medio'], precos
    else:
        return 0, []

# Exemplo de uso
if __name__ == "__main__":
    # Inicializar API
    api = WebmotorsAPI()
    
    # Exemplo 1: Busca básica
    print("=== Exemplo 1: BMW X5 ===")
    resultado = api.buscar_precos("BMW", "X5", limite=5)
    
    if resultado['sucesso']:
        stats = resultado['estatisticas']
        print(f"Encontrados: {stats['quantidade']} anúncios")
        print(f"Preço médio: R$ {stats['preco_medio']:,.2f}")
        print(f"Faixa de preço: R$ {stats['preco_minimo']:,.2f} - R$ {stats['preco_maximo']:,.2f}")
        
        print("\nPrimeiros anúncios:")
        for i, anuncio in enumerate(resultado['anuncios'][:3], 1):
            print(f"{i}. {anuncio['titulo']} - R$ {anuncio['preco']:,.2f}")
    else:
        print(f"Erro: {resultado['erro']}")
    
    print("\n" + "="*50)
    
    # Exemplo 2: Usando função simplificada
    print("=== Exemplo 2: Função Simplificada ===")
    preco_medio, precos = buscar_precos_webmotors("Toyota", "Corolla", 3)
    
    if preco_medio > 0:
        print(f"Preço médio: R$ {preco_medio:,.2f}")
        print(f"Preços encontrados: {[f'R$ {p:,.2f}' for p in precos]}")
    else:
        print("Nenhum resultado encontrado")